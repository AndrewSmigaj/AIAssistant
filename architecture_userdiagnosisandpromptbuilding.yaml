architecture: Unified AI Assistant Window with Mode Switching
version: 2.0.0
status: design_ready_for_implementation
purpose: |
  Extend AIAssistantWindow to support three modes in a single unified interface:
  1. Scene Builder (existing) - Natural language scene building
  2. Example Builder (new) - Iterative prompt library example creation
  3. Prompt Library (new) - Browse and enable/disable prompt library examples

  All modes share the same chat-style interface with mode-specific behaviors.
  Uses dictionary-based state isolation to prevent conversation interference.

design_principles:
  - Single unified window: No separate windows, everything accessible via mode switcher
  - Reuse existing UI: Chat log, prompt input, header toolbar all reused across modes
  - State isolation: Each mode has independent conversation history and response IDs
  - Natural workflows: Conversational example refinement, chat-based scene building
  - Minimal code duplication: Shared UI infrastructure, mode-specific rendering logic

overview: |
  This architecture adds a mode switcher (segmented control) to AIAssistantWindow,
  allowing users to switch between Scene Builder, Example Builder, and Prompt Library
  without leaving the window.

  Key Features:
  - Mode switcher: Horizontal segmented control [Scene Builder][Example Builder][Prompt Library]
  - State isolation: Each mode has separate conversation, logs, and response IDs
  - Shared UI: Log area, prompt input, header toolbar reused with mode-aware rendering
  - Context toggle: Checkbox to include/exclude scene & prefab data (for questions)
  - Example Builder: Generate ‚Üí Execute ‚Üí Diagnose ‚Üí Save workflow in chat interface
  - Prompt Library: Embedded tree view (30%) + preview pane (70%)

components:

  # ============================================================================
  # 1. MODE SWITCHING INFRASTRUCTURE
  # ============================================================================

  mode_switching:
    enum_definition: |
      public enum WindowMode
      {
          SceneBuilder,   // Natural language scene building (existing)
          ExampleBuilder, // Generate and refine prompt library examples
          PromptLibrary   // Browse and enable/disable prompt library
      }

    state_management: |
      // Current mode
      private WindowMode _currentMode = WindowMode.SceneBuilder;

      // Mode-specific state (isolated to prevent interference)
      private Dictionary<WindowMode, string> _modeResponseIds = new Dictionary<WindowMode, string>();
      private Dictionary<WindowMode, List<string>> _modeLogs = new Dictionary<WindowMode, List<string>>();
      private Dictionary<WindowMode, string> _modePrompts = new Dictionary<WindowMode, string>();
      private Dictionary<WindowMode, Vector2> _modeScrollPositions = new Dictionary<WindowMode, Vector2>();
      private Dictionary<WindowMode, string> _modeLastMessages = new Dictionary<WindowMode, string>();

      // Helper properties for cleaner code
      private string CurrentResponseId
      {
          get => _modeResponseIds.GetValueOrDefault(_currentMode);
          set => _modeResponseIds[_currentMode] = value;
      }

      private List<string> CurrentLog
      {
          get
          {
              if (!_modeLogs.ContainsKey(_currentMode))
                  _modeLogs[_currentMode] = new List<string>();
              return _modeLogs[_currentMode];
          }
      }

      private string CurrentPrompt
      {
          get => _modePrompts.GetValueOrDefault(_currentMode, "");
          set => _modePrompts[_currentMode] = value;
      }

    mode_switcher_ui: |
      void DisplayModeSelector()
      {
          // Segmented control style (Unity's miniButtonLeft/Mid/Right)
          GUIStyle leftStyle = new GUIStyle(EditorStyles.miniButtonLeft);
          GUIStyle middleStyle = new GUIStyle(EditorStyles.miniButtonMid);
          GUIStyle rightStyle = new GUIStyle(EditorStyles.miniButtonRight);

          // Highlight selected mode
          if (_currentMode == WindowMode.SceneBuilder)
              leftStyle.normal.background = leftStyle.active.background;
          if (_currentMode == WindowMode.ExampleBuilder)
              middleStyle.normal.background = middleStyle.active.background;
          if (_currentMode == WindowMode.PromptLibrary)
              rightStyle.normal.background = rightStyle.active.background;

          if (GUILayout.Toggle(_currentMode == WindowMode.SceneBuilder, "Scene Builder", leftStyle))
              SwitchMode(WindowMode.SceneBuilder);
          if (GUILayout.Toggle(_currentMode == WindowMode.ExampleBuilder, "Example Builder", middleStyle))
              SwitchMode(WindowMode.ExampleBuilder);
          if (GUILayout.Toggle(_currentMode == WindowMode.PromptLibrary, "Prompt Library", rightStyle))
              SwitchMode(WindowMode.PromptLibrary);
      }

      void SwitchMode(WindowMode newMode)
      {
          if (_currentMode != newMode)
          {
              _currentMode = newMode;
              Repaint();
          }
      }

  # ============================================================================
  # 2. UI STRUCTURE - SHARED COMPONENTS
  # ============================================================================

  ui_structure:
    current_layout: |
      AIAssistantWindow.OnGUI() structure:
      1. DisplayHeader() - Toolbar with mode switcher and buttons
      2. DisplayLogArea() - Scrollable message history (mode-aware)
      3. DisplayPendingActions() - Scene Builder only (tool approvals)
      4. DisplayExampleBuilderActions() - Example Builder only (execute button)
      5. DisplayPromptLibraryBrowser() - Prompt Library only (tree + preview)
      6. DisplayPromptInput() - Text area + submit (Scene Builder & Example Builder)

    header_toolbar:
      layout: |
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ [Scene Builder‚ñº][Example Builder][Prompt Library]  [‚öô][üîÑ][‚å´]‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

      buttons_by_mode:
        shared:
          - button: "Copy Last Response"
            availability: All modes
            behavior: Copies CurrentResponseId's last message to clipboard

        scene_builder:
          - button: "Refresh Index"
            behavior: Re-index project and scene
          - button: "Clear Conversation"
            behavior: Clear CurrentLog and reset CurrentResponseId

        example_builder:
          - button: "Save Example"
            behavior: Save generated example to PromptLibrary
            enabled: Only when _generatedExample != null
          - button: "Clear"
            behavior: Clear CurrentLog and reset conversation

        prompt_library:
          - button: "Refresh Library"
            behavior: Rescan PromptLibrary folder for new files

      context_toggle:
        location: Header toolbar (after mode switcher, before utility buttons)
        control: Toggle checkbox
        label: "üìã Include scene & prefabs"
        default: true (checked)
        tooltip: "When enabled, sends scene JSON and prefab catalog to AI. Disable for general questions."
        affects: Only Scene Builder and Example Builder modes
        implementation: |
          private bool _includeProjectContext = true;

          // In header:
          _includeProjectContext = GUILayout.Toggle(_includeProjectContext,
              new GUIContent("üìã Include scene & prefabs",
              "Disable for general questions without scene context"),
              EditorStyles.toolbarButton, GUILayout.Width(180));

    log_area:
      shared_structure: |
        void DisplayLogArea()
        {
            EditorGUILayout.LabelField("Log", EditorStyles.boldLabel);

            Vector2 scrollPos = _modeScrollPositions.GetValueOrDefault(_currentMode);
            scrollPos = EditorGUILayout.BeginScrollView(scrollPos, GUILayout.Height(200));
            _modeScrollPositions[_currentMode] = scrollPos;

            switch (_currentMode)
            {
                case WindowMode.SceneBuilder:
                    DisplaySceneBuilderLog();
                    break;
                case WindowMode.ExampleBuilder:
                    DisplayExampleBuilderLog();
                    break;
                case WindowMode.PromptLibrary:
                    DisplayPromptLibraryPreview();
                    break;
            }

            EditorGUILayout.EndScrollView();
        }

      scene_builder_log:
        behavior: Existing behavior (displays conversation history)
        implementation: No changes needed

      example_builder_log:
        behavior: |
          Displays example generation conversation:
          - User prompts
          - Generated examples (with syntax highlighting)
          - Diagnosis messages
          - Execution results

        example_output: |
          [10:23:45] [User] Generate example: box under table using box.top ‚Üí table.bottom
          [10:23:47] [AI] Generated example:

          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          EXAMPLE: Box Under Table

          Step 0: TableSquareMedium scale=[0.341,0.341,0.341]
          Step 7: box_pivot = table_bottom_world - box.top_world_offset
          OUTPUT: position=[2.0, -0.497, -2.0], rotation=[0,0,0,1]
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

          [10:24:10] [System] Execution complete. Objects created.
          [10:25:33] [User] Box is tilted 45¬∞ but should be aligned
          [10:25:35] [AI] Diagnosis: Rotation not calculated properly...

      prompt_library_preview:
        behavior: Shows selected prompt file content with syntax highlighting
        layout: |
          If no prompt selected:
            Show help box: "Select a prompt below to preview"
          Else:
            Show prompt content as TextArea (read-only)

    prompt_input:
      shared_structure: |
        void DisplayPromptInput()
        {
            if (_currentMode == WindowMode.PromptLibrary)
                return; // Prompt Library is browse-only

            GUILayout.Space(10);

            string placeholder = GetPlaceholderForMode();
            EditorGUILayout.LabelField(placeholder, EditorStyles.boldLabel);

            CurrentPrompt = EditorGUILayout.TextArea(CurrentPrompt, GUILayout.Height(60));

            if (GUILayout.Button("Submit (Ctrl+Enter)", GUILayout.Height(30)))
            {
                OnSubmitPrompt();
            }

            GUILayout.Space(5);
        }

      placeholders:
        scene_builder: "Your Prompt (e.g., 'Place a table in the center'):"
        example_builder: "Example Request (e.g., 'Generate: box under table using box.top ‚Üí table.bottom'):"

  # ============================================================================
  # 3. SCENE BUILDER MODE (EXISTING - MINIMAL CHANGES)
  # ============================================================================

  scene_builder_mode:
    changes_required: |
      1. Wrap existing logic in HandleSceneBuilderPrompt()
      2. Use CurrentResponseId instead of _lastResponseId
      3. Append to CurrentLog instead of _logEntries
      4. Check _includeProjectContext when building context

    implementation: |
      void HandleSceneBuilderPrompt(string prompt)
      {
          EditorUtility.DisplayProgressBar("AI Assistant", "Building context...", 0.3f);

          string systemMessage, toolsJson;
          string userMessage = ContextBuilder.BuildContextPack(prompt,
              _settings.TokenBudget, out systemMessage, out toolsJson, _includeProjectContext);

          EditorUtility.DisplayProgressBar("AI Assistant", "Calling OpenAI API...", 0.6f);

          var plan = OpenAIClient.SendRequest(_settings, systemMessage, userMessage,
              CurrentResponseId, null, toolsJson);

          if (plan.Success)
          {
              if (!string.IsNullOrEmpty(plan.Message))
              {
                  _modeLastMessages[_currentMode] = plan.Message;
                  AppendLog($"[AI] {plan.Message}", LogType.Log);
              }

              if (plan.Actions != null && plan.Actions.Count > 0)
              {
                  _pendingActions = plan.Actions;
                  _actionCheckboxes = new bool[plan.Actions.Count];
                  AppendLog($"[System] {plan.Actions.Count} action(s) pending approval", LogType.Log);
              }

              CurrentResponseId = plan.ResponseId;
          }
          else
          {
              AppendLog($"[Error] {plan.ErrorMessage}", LogType.Error);
          }
      }

    context_builder_modification: |
      // In ContextBuilder.cs (line 29)
      public static string BuildContextPack(string userPrompt, int tokenBudget,
          out string systemMessage, out string toolsJson,
          bool includeProjectContext = true)
      {
          var sysSb = new StringBuilder();
          // ... build systemMessage (algorithm + prompt library) ...
          systemMessage = sysSb.ToString();

          var sb = new StringBuilder();

          if (includeProjectContext)
          {
              // Section 2: Project Metadata
              sb.AppendLine("## Project Metadata");
              string projectMetadata = ReadArtifact("ProjectMetadata.json");
              sb.AppendLine(projectMetadata);

              // Section 3: Active Scene
              sb.AppendLine("## Active Scene");
              string sceneArtifact = ReadArtifact($"{activeScene.name}.json");
              sb.AppendLine(sceneArtifact);

              // Section 4: Prefab Catalog
              sb.AppendLine("## Available Prefabs Catalog");
              string catalogJson = GeneratePrefabCatalog();
              sb.AppendLine(catalogJson);
          }

          // User prompt (always included)
          sb.AppendLine($"User Request: {userPrompt}");

          toolsJson = DynamicToolGenerator.GenerateToolsJson(selectedTags);
          return sb.ToString();
      }

  # ============================================================================
  # 4. EXAMPLE BUILDER MODE
  # ============================================================================

  example_builder_mode:
    purpose: Generate, execute, diagnose, and save prompt library examples

    state_fields: |
      // Example Builder specific state
      private ExampleGenerationResult _generatedExample;
      private List<GameObject> _createdObjects = new List<GameObject>();

      class ExampleGenerationResult
      {
          public string ExampleText;
          public string ScenarioDescription;
          public int IterationCount;
      }

    workflow:
      step_1_generate:
        user_prompt: "Generate example: Place box under table using box.top ‚Üí table.bottom"
        implementation: |
          void HandleExampleBuilderPrompt(string prompt)
          {
              if (prompt.StartsWith("Generate", StringComparison.OrdinalIgnoreCase))
              {
                  GenerateExample(prompt);
              }
              else if (prompt.StartsWith("Save", StringComparison.OrdinalIgnoreCase))
              {
                  SaveExample(prompt);
              }
              else
              {
                  // Treat as diagnosis feedback
                  DiagnoseAndRefine(prompt);
              }
          }

          void GenerateExample(string prompt)
          {
              EditorUtility.DisplayProgressBar("Example Builder", "Generating...", 0.5f);

              // Extract scenario from prompt (remove "Generate example:" prefix)
              string scenario = prompt.Replace("Generate example:", "").Trim();

              // Build context for example generation
              string systemMessage = BuildExampleGenerationSystemMessage();
              string userMessage = $"Generate a complete Step 0-5 example demonstrating: {scenario}\n\n" +
                  "Requirements:\n" +
                  "- Follow structure of lamp_on_scaled_table.txt\n" +
                  "- Use quaternions [x,y,z,w] (NOT Euler angles)\n" +
                  "- Show R_ls transformation explicitly\n" +
                  "- Include Step 0 metadata writedown\n" +
                  "- Include Step 5 verification\n" +
                  "- Format as markdown\n\n" +
                  "Generate the example now:";

              var response = OpenAIClient.SendRequest(_settings, systemMessage, userMessage,
                  CurrentResponseId, null, "[]");

              if (response.Success && !string.IsNullOrEmpty(response.Message))
              {
                  AppendLog($"[AI] {response.Message}", LogType.Log);

                  _generatedExample = new ExampleGenerationResult
                  {
                      ExampleText = response.Message,
                      ScenarioDescription = scenario,
                      IterationCount = 1
                  };

                  AppendLog("[System] Example generated. Click 'Execute Example' to test.", LogType.Log);
                  CurrentResponseId = response.ResponseId;
              }
              else
              {
                  AppendLog($"[Error] {response.ErrorMessage}", LogType.Error);
              }
          }

        system_message_construction: |
          string BuildExampleGenerationSystemMessage()
          {
              // Reuse ContextBuilder for algorithm + prompt library
              string systemMessage, toolsJson;
              ContextBuilder.BuildContextPack("", _settings.TokenBudget,
                  out systemMessage, out toolsJson, includeProjectContext: false);

              // Add example-specific instructions
              var sb = new StringBuilder(systemMessage);
              sb.AppendLine();
              sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
              sb.AppendLine("## EXAMPLE GENERATION INSTRUCTIONS");
              sb.AppendLine("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
              sb.AppendLine();
              sb.AppendLine("You are generating TEACHING EXAMPLES for the prompt library.");
              sb.AppendLine("Examples demonstrate correct SLS methodology step-by-step.");
              sb.AppendLine();
              sb.AppendLine("Required structure:");
              sb.AppendLine("1. Title: EXAMPLE: {description}");
              sb.AppendLine("2. Goal: Clear statement of what to demonstrate");
              sb.AppendLine("3. Given: Scene context (floor, walls, etc.)");
              sb.AppendLine("4. Step 0: WRITE DOWN metadata (scale, R_ls, semantic points)");
              sb.AppendLine("5. Step 1-5: SLS transformations with calculations");
              sb.AppendLine("6. OUTPUT TO TOOL: position, rotation, scale");
              sb.AppendLine("7. KEY TAKEAWAYS: Educational notes");
              sb.AppendLine();
              sb.AppendLine("CRITICAL:");
              sb.AppendLine("- Use quaternions [x,y,z,w] (NEVER Euler angles)");
              sb.AppendLine("- Show R_ls transformation explicitly");
              sb.AppendLine("- Include verification calculations");
              sb.AppendLine("- Format as markdown with clear sections");

              return sb.ToString();
          }

      step_2_execute:
        ui_component: |
          void DisplayExampleBuilderActions()
          {
              if (_currentMode != WindowMode.ExampleBuilder || _generatedExample == null)
                  return;

              GUILayout.Space(10);
              EditorGUILayout.LabelField("Actions:", EditorStyles.boldLabel);

              EditorGUILayout.BeginHorizontal();

              if (GUILayout.Button("‚ñ∂Ô∏è Execute Example", GUILayout.Height(30)))
              {
                  OnExecuteExample();
              }

              if (GUILayout.Button("üîÑ Regenerate", GUILayout.Height(30)))
              {
                  OnRegenerateExample();
              }

              if (GUILayout.Button("üßπ Clear Scene", GUILayout.Height(30)))
              {
                  OnClearCreatedObjects();
              }

              EditorGUILayout.EndHorizontal();
              GUILayout.Space(10);
          }

        implementation: |
          void OnExecuteExample()
          {
              if (_generatedExample == null)
                  return;

              AppendLog("[System] Executing example...", LogType.Log);

              // Send example to AI, ask it to execute the scenario
              string systemMessage = BuildExampleExecutionSystemMessage();
              string userMessage = $"Execute this placement scenario:\n\n" +
                  $"Scenario: {_generatedExample.ScenarioDescription}\n\n" +
                  $"Follow the calculations shown in this example:\n" +
                  $"```\n{_generatedExample.ExampleText}\n```\n\n" +
                  $"Generate the appropriate tool calls.";

              var plan = OpenAIClient.SendRequest(_settings, systemMessage, userMessage,
                  CurrentResponseId, null, toolsJson);

              if (plan.Success)
              {
                  if (plan.Actions != null && plan.Actions.Count > 0)
                  {
                      // Execute immediately (no approval needed in Example Builder)
                      var results = DynamicPlanApplier.ApplyPlan(plan.Actions, _settings.PreviewMode);

                      // Track created objects for cleanup
                      foreach (var result in results)
                      {
                          if (result.Success && result.CreatedObject != null)
                          {
                              _createdObjects.Add(result.CreatedObject);
                          }
                      }

                      // Re-index scene
                      Scene activeScene = SceneManager.GetActiveScene();
                      if (activeScene.isDirty)
                          EditorSceneManager.SaveScene(activeScene);
                      ProjectIndexer.IndexAll();

                      AppendLog($"[System] Created {results.Count} object(s). Inspect the scene.", LogType.Log);
                  }

                  CurrentResponseId = plan.ResponseId;
              }
              else
              {
                  AppendLog($"[Error] {plan.ErrorMessage}", LogType.Error);
              }
          }

      step_3_diagnose:
        user_prompt: "Box is floating 0.5m above table"
        implementation: |
          void DiagnoseAndRefine(string observation)
          {
              AppendLog($"[User] {observation}", LogType.Log);
              AppendLog("[System] Diagnosing...", LogType.Log);

              string systemMessage = BuildExampleGenerationSystemMessage(); // Same as generation
              string userMessage = $"I executed this example:\n" +
                  $"```\n{_generatedExample.ExampleText}\n```\n\n" +
                  $"I observed: {observation}\n\n" +
                  $"Please diagnose:\n" +
                  $"1. Which Step (0-5) contains the error?\n" +
                  $"2. What exactly is wrong?\n" +
                  $"3. Why does this cause the observed symptom?\n\n" +
                  $"Then provide:\n" +
                  $"- DIAGNOSIS: Your analysis\n" +
                  $"- CORRECTED EXAMPLE: Updated version with fixes\n" +
                  $"- LESSON LEARNED: Key concept to remember\n\n" +
                  $"Format response as markdown with these three sections.";

              var response = OpenAIClient.SendRequest(_settings, systemMessage, userMessage,
                  CurrentResponseId, null, "[]");

              if (response.Success && !string.IsNullOrEmpty(response.Message))
              {
                  AppendLog($"[AI] {response.Message}", LogType.Log);

                  // Update example with corrected version
                  _generatedExample.ExampleText = ExtractCorrectedExample(response.Message);
                  _generatedExample.IterationCount++;

                  AppendLog($"[System] Example refined (iteration {_generatedExample.IterationCount}). " +
                      "Review and re-execute if needed.", LogType.Log);

                  CurrentResponseId = response.ResponseId;
              }
              else
              {
                  AppendLog($"[Error] {response.ErrorMessage}", LogType.Error);
              }
          }

      step_4_save:
        user_prompt: "Save as box_under_table in Furniture category"
        implementation: |
          void SaveExample(string prompt)
          {
              if (_generatedExample == null)
              {
                  AppendLog("[Error] No example to save. Generate an example first.", LogType.Error);
                  return;
              }

              // Parse: "Save as {name} in {category} category"
              var match = Regex.Match(prompt, @"Save as (\w+) in (\w+)", RegexOptions.IgnoreCase);
              if (!match.Success)
              {
                  AppendLog("[Error] Format: 'Save as {name} in {category}'", LogType.Error);
                  return;
              }

              string name = match.Groups[1].Value;
              string category = match.Groups[2].Value;

              // Construct path
              string basePath = "Assets/ContextAwareSceneBuilder/PromptLibrary/Examples";
              string fullPath = $"{basePath}/{category}/{name}.txt";

              try
              {
                  // Ensure directory exists
                  Directory.CreateDirectory(Path.GetDirectoryName(fullPath));

                  // Write example
                  File.WriteAllText(fullPath, _generatedExample.ExampleText);

                  // Refresh AssetDatabase
                  AssetDatabase.Refresh();

                  // Add to PromptLibrarySettings (auto-enabled)
                  var settings = PromptLibrarySettings.GetOrCreateSettings();
                  string relativePath = $"Examples/{category}/{name}.txt";
                  settings.SetPromptEnabled(relativePath, true);

                  AppendLog($"[System] Example saved to {fullPath}", LogType.Log);
                  AppendLog("[AI] Example saved successfully. You can now enable it in the Prompt Library " +
                      "to include it in Scene Builder's context.", LogType.Log);

                  // Switch to Prompt Library mode to show new example
                  SwitchMode(WindowMode.PromptLibrary);
              }
              catch (Exception ex)
              {
                  AppendLog($"[Error] Failed to save: {ex.Message}", LogType.Error);
              }
          }

  # ============================================================================
  # 5. PROMPT LIBRARY MODE
  # ============================================================================

  prompt_library_mode:
    purpose: Browse prompt library, enable/disable examples, preview content

    layout: |
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                    ‚îÇ                                   ‚îÇ
      ‚îÇ  TREE VIEW         ‚îÇ  PREVIEW PANE                     ‚îÇ
      ‚îÇ  (30% width)       ‚îÇ  (70% width)                      ‚îÇ
      ‚îÇ                    ‚îÇ                                   ‚îÇ
      ‚îÇ  ‚òë Examples/       ‚îÇ  [Selected prompt content]        ‚îÇ
      ‚îÇ    ‚òë Beds/         ‚îÇ                                   ‚îÇ
      ‚îÇ      ‚òë bed_agai... ‚îÇ                                   ‚îÇ
      ‚îÇ      ‚òê bed_cent... ‚îÇ                                   ‚îÇ
      ‚îÇ    ‚òê Tables/       ‚îÇ                                   ‚îÇ
      ‚îÇ  ‚òë Reference/      ‚îÇ                                   ‚îÇ
      ‚îÇ    ‚òë semantic_a... ‚îÇ                                   ‚îÇ
      ‚îÇ                    ‚îÇ                                   ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    state_fields: |
      // Prompt Library specific state
      private PromptLibrarySettings _promptSettings;
      private List<string> _allPromptPaths;
      private string _selectedPromptPath;
      private Dictionary<string, bool> _expandedFolders = new Dictionary<string, bool>();

    implementation: |
      void OnGUI_PromptLibraryMode()
      {
          EditorGUILayout.BeginHorizontal();

          // Left: Tree view (30%)
          EditorGUILayout.BeginVertical(GUILayout.Width(position.width * 0.3f));
          DisplayPromptTree();
          EditorGUILayout.EndVertical();

          // Right: Preview (70%)
          EditorGUILayout.BeginVertical();
          DisplayPromptPreview();
          EditorGUILayout.EndVertical();

          EditorGUILayout.EndHorizontal();
      }

      void DisplayPromptTree()
      {
          EditorGUILayout.LabelField("Prompt Library", EditorStyles.boldLabel);

          Vector2 scrollPos = _modeScrollPositions.GetValueOrDefault(_currentMode);
          scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
          _modeScrollPositions[_currentMode] = scrollPos;

          // Group prompts by folder
          var folders = _allPromptPaths
              .GroupBy(p => Path.GetDirectoryName(p))
              .OrderBy(g => g.Key);

          foreach (var folder in folders)
          {
              string folderName = folder.Key;
              bool isExpanded = _expandedFolders.GetValueOrDefault(folderName, true);

              // Folder header with foldout
              EditorGUILayout.BeginHorizontal();
              isExpanded = EditorGUILayout.Foldout(isExpanded, folderName, true);
              _expandedFolders[folderName] = isExpanded;
              EditorGUILayout.EndHorizontal();

              if (isExpanded)
              {
                  EditorGUI.indentLevel++;

                  foreach (var promptPath in folder)
                  {
                      EditorGUILayout.BeginHorizontal();

                      // Checkbox for enable/disable
                      bool isEnabled = _promptSettings.IsPromptEnabled(promptPath);
                      bool newEnabled = EditorGUILayout.Toggle(isEnabled, GUILayout.Width(20));

                      if (newEnabled != isEnabled)
                      {
                          _promptSettings.SetPromptEnabled(promptPath, newEnabled);
                          EditorUtility.SetDirty(_promptSettings);
                          AssetDatabase.SaveAssets();
                      }

                      // Filename button for selection
                      string fileName = Path.GetFileName(promptPath);
                      if (GUILayout.Button(fileName, EditorStyles.label))
                      {
                          _selectedPromptPath = promptPath;
                          Repaint();
                      }

                      EditorGUILayout.EndHorizontal();
                  }

                  EditorGUI.indentLevel--;
              }
          }

          EditorGUILayout.EndScrollView();
      }

      void DisplayPromptPreview()
      {
          EditorGUILayout.LabelField("Preview", EditorStyles.boldLabel);

          if (string.IsNullOrEmpty(_selectedPromptPath))
          {
              EditorGUILayout.HelpBox("Select a prompt to preview its content.", MessageType.Info);
          }
          else
          {
              string fullPath = PromptLibraryLoader.GetFullPath(_selectedPromptPath);
              if (File.Exists(fullPath))
              {
                  Vector2 scrollPos = _previewScrollPosition;
                  scrollPos = EditorGUILayout.BeginScrollView(scrollPos);
                  _previewScrollPosition = scrollPos;

                  string content = File.ReadAllText(fullPath);
                  EditorGUILayout.TextArea(content, EditorStyles.wordWrappedLabel,
                      GUILayout.ExpandHeight(true));

                  EditorGUILayout.EndScrollView();
              }
              else
              {
                  EditorGUILayout.HelpBox($"File not found: {fullPath}", MessageType.Warning);
              }
          }
      }

      void RefreshPromptList()
      {
          _allPromptPaths = PromptLibraryLoader.ScanPromptFiles();
          Repaint();
      }

  # ============================================================================
  # 6. IMPLEMENTATION EFFORT & PHASES
  # ============================================================================

  implementation_effort:
    total_hours: 14-16 hours

    breakdown:
      phase_1_mode_infrastructure:
        hours: 3
        tasks:
          - Add WindowMode enum
          - Add mode-specific state dictionaries
          - Implement SwitchMode() method
          - Add mode selector UI (segmented control)
          - Test mode switching (state isolation)

      phase_2_refactor_existing:
        hours: 4
        tasks:
          - Extract DisplaySceneBuilderLog() from DisplayLogArea()
          - Make header buttons mode-aware (conditional rendering)
          - Update OnSubmitPrompt() to route by mode (HandleSceneBuilderPrompt)
          - Update AppendLog() to append to CurrentLog
          - Add _includeProjectContext toggle
          - Modify ContextBuilder.BuildContextPack() to accept includeProjectContext parameter
          - Test Scene Builder mode (ensure no regression)

      phase_3_example_builder:
        hours: 4
        tasks:
          - Add Example Builder state fields (_generatedExample, _createdObjects)
          - Implement HandleExampleBuilderPrompt() (routing logic)
          - Implement GenerateExample() (AI generation)
          - Implement OnExecuteExample() (execution through DynamicPlanApplier)
          - Implement DiagnoseAndRefine() (multi-turn diagnosis)
          - Implement SaveExample() (file save + PromptLibrarySettings update)
          - Implement DisplayExampleBuilderActions() (Execute/Regenerate buttons)
          - Test full workflow (generate ‚Üí execute ‚Üí diagnose ‚Üí save)

      phase_4_prompt_library:
        hours: 2
        tasks:
          - Add Prompt Library state fields (_allPromptPaths, _selectedPromptPath, _expandedFolders)
          - Implement DisplayPromptTree() (simplified tree view with checkboxes)
          - Implement DisplayPromptPreview() (file content display)
          - Implement RefreshPromptList()
          - Test enable/disable functionality
          - Verify preview updates correctly

      phase_5_polish_and_test:
        hours: 3
        tasks:
          - UI polish (spacing, colors, icons)
          - Edge case handling (empty states, errors)
          - Test mode switching (state isolation verification)
          - Test conversation continuity in each mode
          - Test context toggle (Scene Builder questions mode)
          - Performance testing (large prompt library)
          - Documentation (inline comments, README update)

  # ============================================================================
  # 7. VALIDATION & TESTING
  # ============================================================================

  validation:
    state_isolation_tests:
      test_1: Switch from Scene Builder (mid-conversation) to Example Builder
      expected: Scene Builder conversation preserved when switching back

      test_2: Generate example in Example Builder, switch to Scene Builder
      expected: Example Builder state (generated example) preserved when switching back

      test_3: Enable prompts in Prompt Library, switch to Scene Builder, submit request
      expected: Enabled prompts included in AI context

    conversation_continuity_tests:
      test_1: Scene Builder multi-turn ("Place bed" ‚Üí "Make it bigger")
      expected: AI remembers bed from previous turn

      test_2: Example Builder multi-turn (Generate ‚Üí Diagnose ‚Üí Diagnose again)
      expected: AI remembers previous diagnosis iterations

    context_toggle_tests:
      test_1: Scene Builder with toggle OFF, ask "Explain SLS"
      expected: AI receives no scene/prefab data, answers conceptually

      test_2: Scene Builder with toggle ON, ask "Place table"
      expected: AI receives full scene context, places table correctly

    example_workflow_tests:
      test_1: Generate example ‚Üí Execute ‚Üí Observe correct placement ‚Üí Save
      expected: Example saved to PromptLibrary, auto-enabled

      test_2: Generate example ‚Üí Execute ‚Üí Observe error ‚Üí Diagnose ‚Üí Re-execute ‚Üí Save
      expected: Corrected example saved after diagnosis

notes:
  why_mode_switching: |
    Mode switching provides a unified interface for all AI Assistant workflows
    without the complexity of separate windows or tabbed UI. Users can quickly
    switch between scene building, example creation, and library management
    while maintaining independent conversation contexts.

  state_management_rationale: |
    Dictionary-based state isolation prevents conversation interference between modes.
    Each mode has its own response ID, log, and prompt history. This ensures that
    switching from Scene Builder mid-conversation doesn't lose context, and Example
    Builder diagnosis iterations don't pollute Scene Builder's conversation history.

  reuse_vs_new_code: |
    This architecture maximizes code reuse:
    - Shared: Log area structure, prompt input, header toolbar, OpenAI client calls
    - New: Mode routing logic, Example Builder workflow, Prompt Library tree view
    - Modified: Scene Builder prompt handling (extract to HandleSceneBuilderPrompt)

    Estimated code distribution:
    - Reused: 60% (existing AIAssistantWindow infrastructure)
    - New: 30% (Example Builder + Prompt Library modes)
    - Modified: 10% (Scene Builder refactoring for mode support)

  execution_validation_clarification: |
    Example Builder execution validates that examples teach correct patterns:
    1. Generate example (AI produces Step 0-5 walkthrough)
    2. Execute example (AI reads example, independently calculates, generates tool calls)
    3. If example teaches wrong pattern ‚Üí AI calculates wrong ‚Üí user sees error
    4. Diagnose (AI corrects example based on observed error)
    5. Re-execute (AI re-calculates using corrected example)

    This is NOT circular - the example is teaching material, and execution tests
    if the teaching is correct by having the AI learn from it and apply the pattern.

  future_enhancements: |
    - Visual diff showing before/after corrections
    - Screenshot capture + GPT-4V analysis
    - Batch example generation
    - Example-based regression testing
    - Community example repository
