# Architecture: Speed Up and Feedback for Interactions

## Problem

AI requests freeze UI with minimal feedback. User sees "Submitting tool results... 50%" but doesn't know what's actually happening.

## What The Code Does

### OnExecuteSelected
1. Execute actions (fast)
2. Save scene if dirty
3. **ProjectIndexer.IndexAll()** - re-indexes entire project
4. **ContextBuilder.BuildContextPack()** - builds system message + loads prompts + generates prefab catalog + reads scene artifacts
5. **OpenAIClient.SendRequest()** - uploads and waits for API

### OnSubmitPrompt
1. **ContextBuilder.BuildContextPack()** - same as above
2. **OpenAIClient.SendRequest()** - same as above

Note: OnSubmitPrompt does NOT re-index, uses existing artifacts

## Implementation Plan

### Phase 1: Show What's Happening (Primary Goal)

**Current**:
```csharp
EditorUtility.DisplayProgressBar("AI Assistant", "Submitting tool results...", 0.5f);
```

**Change To**:
```csharp
// Non-blocking UI with detailed progress
_isProcessing = true;
_processingStages = new[] {
    "Executing actions",
    "Saving scene",
    "Indexing project",
    "Indexing scenes",
    "Loading prefab catalog",
    "Loading prompts",
    "Building context",
    "Uploading to API",
    "Waiting for response"
};
_currentStage = 0;

// Update _currentStage after each step
// Show in window with progress bar
// Allow user to scroll logs, read messages
// Disable Submit button while processing
```

**Benefits**:
- User knows exactly what's happening
- Can see if something is stuck
- Can still read logs during wait
- Professional feel

### Phase 2: Context Caching (Secondary Goal)

**What Can Be Cached**:
1. System message (SLS algorithm text) - only changes with code updates
2. Tools JSON (tool definitions) - only changes with code updates
3. Prefab catalog JSON - only changes when prefabs change or user toggles categories
4. Prompt file content - only changes when user toggles prompts

**What Cannot Be Cached**:
- Scene context (changes after every action execution)

**Cache Strategy**:
```csharp
// In AIAssistantWindow
private string _cachedSystemMessage;
private string _cachedToolsJson;
private string _cachedPrefabCatalog;
private string _cachedPrompts;
private bool _cacheValid = false;

// Invalidate cache when:
- User toggles prompt checkboxes
- Prefab categories changed (AssetDatabase callback)
- Code reload (cache lost naturally)
```

**Modify ContextBuilder.BuildContextPack()**:
```csharp
public static string BuildContextPack(
    string userPrompt,
    int tokenBudget,
    out string systemMessage,
    out string toolsJson,
    CachedContext cache = null  // NEW
)
{
    if (cache != null && cache.IsValid)
    {
        systemMessage = cache.SystemMessage;
        toolsJson = cache.ToolsJson;
        // Only rebuild scene context
    }
    else
    {
        // Full rebuild
    }
}
```

**Expected Impact**:
- System message: save ~50ms (small but free)
- Tools JSON: save ~10ms (negligible)
- Prefab catalog: save 1-3s (significant if many prefabs)
- Prompts: save 100-500ms (depends on file count)
- **Total potential savings**: 1-4s per request

### Phase 3: Smarter Scene Indexing (If Needed)

**Current**: ProjectIndexer.IndexAll() re-scans entire scene after actions

**Optimization**: Only index what changed
```csharp
// After executing 5 actions, we know exactly which 5 objects were created
// Could skip full re-index and just append new objects to artifact

ProjectIndexer.IndexChangedObjects(createdObjects);
// vs
ProjectIndexer.IndexAll();
```

**Tradeoff**: More complex, risk of desync if we miss something

**Recommendation**: Implement Phase 1 first, measure timings, then decide if Phase 3 is needed

## Implementation Order

1. Phase 1 - Detailed feedback (~2-3 hours)
2. Test and measure actual bottlenecks
3. Phase 2 - Context caching (~2-3 hours)
4. Test and measure improvement
5. Phase 3 - Only if still too slow

## Testing

- Profile each step with Stopwatch to get real timings
- Test with small scene (10 objects) vs large scene (100+ objects)
- Test with few prefabs (10) vs many prefabs (100+)
- Identify actual bottlenecks before optimizing
