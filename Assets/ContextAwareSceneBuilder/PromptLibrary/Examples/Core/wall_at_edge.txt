EXAMPLE 1: Wall at EAST edge of floor - SLS Version

Goal: Place wall at floor's right (east) edge, back face against edge, facing inward

Given: Floor4m created at position [0,0,0], rotation [0,0,0,1] (quaternion), scale [1,1,1]

═══════════════════════════════════════════════════════════════════════
⚠️ CRITICAL: Semantic Point Consistency for Walls
═══════════════════════════════════════════════════════════════════════

Wall4m has TWO face options:
  - "back" at LOCAL Z=-0.121 (includes wall thickness)
  - "front" at LOCAL Z=0.0 (no thickness offset)

When placing multiple walls (N/S/E/W), you MUST use the SAME face for ALL walls!

WRONG: Mix front and back
  → West wall using "front" (Z=0) → thickness extends INTO room (+0.121m intrusion)
  → East wall using "back" (Z=-0.121) → positioned correctly but inconsistent
  → Result: Asymmetric room boundaries, walls intrude different amounts

CORRECT: Use "back" (or "front") for ALL walls
  → Consistent offsets, symmetric room boundaries
  → This example uses wall.back - use it for ALL walls in your room!

═══════════════════════════════════════════════════════════════════════

Step 0 - WRITE DOWN metadata from Prefab Catalog:

  Floor4m:
    scale = [1.0, 1.0, 1.0]
    semanticLocalSpaceRotation (R_ls) = [0, 0, 0, 1] (identity)
    semanticPoints:
      ["right", 4.0, -0.05, -2.0, 1.0, 0.0, 0.0] → east edge, normal points +X
      ["top", 2.0, 0.0, -2.0, 0.0, 1.0, 0.0] → walking surface, normal points +Y

  Wall4m:
    scale = [1.0, 1.0, 1.0]
    semanticLocalSpaceRotation (R_ls) = [0, 0, 0, 1] (identity)
    semanticPoints:
      ["back", 2.0, 1.5, -0.121, 0.0, 0.0, -1.0] → back face, normal points LOCAL -Z
      ["front", 2.0, 1.5, 0.0, 0.0, 0.0, 1.0] → front face, normal points LOCAL +Z
      ["bottom", 2.0, 0.0, -0.061, 0.0, -1.0, 0.0] → floor contact, normal points -Y

    WE CHOOSE: wall.back for this example (use for ALL walls in room!)

Step 1 - Transform wall to SLS:

  wall.back_local = [2.0, 1.5, -0.121]
  wall.back_normal_local = [0, 0, -1]

  Apply R_ls_wall = [0,0,0,1]:
    wall.back_sls = [0,0,0,1] * [2.0, 1.5, -0.121] = [2.0, 1.5, -0.121]
    wall.normal_sls = [0,0,0,1] * [0, 0, -1] = [0, 0, -1]

Step 2 - Calculate alignment in SLS:

  Goal: Wall's back face (LOCAL -Z) should point WORLD -X (westward, into room)

  Transform floor to SLS:
    floor.right_local = [4.0, -0.05, -2.0]
    floor.right_normal_local = [1, 0, 0]

    Apply R_ls_floor = [0,0,0,1]:
      floor.right_sls = [4.0, -0.05, -2.0]
      floor.right_normal_sls = [1, 0, 0]

  Desired alignment in SLS:
    Wall should face inward (westward = -X direction)
    desired_normal_sls = [-1, 0, 0] (pointing west)

  Two-vector alignment:
    Primary (normals):
      q1 = QuaternionFromTo(wall.normal_sls, desired_normal_sls)
      q1 = QuaternionFromTo([0,0,-1], [-1,0,0])

      This is a 90° rotation around Y axis:
      q1 = [0, 0.707, 0, 0.707] (Y=90°)

    Secondary (twist - use floor.top as up reference):
      rotated_up = q1 * wall.up_sls
      rotated_up = q1 * [0,1,0] = [0,1,0] (unchanged, Y-rotation doesn't affect Y-axis)

      projection to plane perpendicular to [-1,0,0]:
        projection = [0,1,0] - ([0,1,0] · [-1,0,0]) * [-1,0,0]
        projection = [0,1,0] - 0 * [-1,0,0] = [0,1,0]

      q2 = QuaternionFromTo([0,1,0], floor.up_sls)
      q2 = QuaternionFromTo([0,1,0], [0,1,0]) = [0,0,0,1] (identity, already aligned)

    Final SLS rotation:
      R_sls_final = q2 * q1 = [0,0,0,1] * [0, 0.707, 0, 0.707]
      R_sls_final = [0, 0.707, 0, 0.707] (90° around Y)

Step 3 - Convert rotation to world:

  R_world_wall = R_sls_final * R_ls_wall
  R_world_wall = [0, 0.707, 0, 0.707] * [0,0,0,1]
  R_world_wall = [0, 0.707, 0, 0.707] (Y=90° rotation)

Step 4 - Calculate position in world:

  A. Get floor.right in world (floor just created - use instance transform):
     p_wl_floor = [0, 0, 0]
     R_wl_floor = [0, 0, 0, 1]
     S_floor = [1, 1, 1]

     Calculate R_ws_floor:
       R_ws_floor = R_wl_floor * Inverse(R_ls_floor)
       R_ws_floor = [0,0,0,1] * [0,0,0,1] = [0,0,0,1]

     Convert floor.right to world:
       Scale: S ⊙ floor.right_sls = [1,1,1] ⊙ [4.0,-0.05,-2.0] = [4.0,-0.05,-2.0]
       Rotate: R_ws * scaled = [0,0,0,1] * [4.0,-0.05,-2.0] = [4.0,-0.05,-2.0]
       Translate: floor.right_world = p_wl + rotated = [0,0,0] + [4.0,-0.05,-2.0]
       floor.right_world = [4.0, -0.05, -2.0]

  B. Calculate wall anchor in world:
     wall.back_local = [2.0, 1.5, -0.121]
     S_wall = [1, 1, 1]

     Formula: anchor_world = R_world_wall * (S ⊙ anchor_local)

     Scale: [1,1,1] ⊙ [2.0, 1.5, -0.121] = [2.0, 1.5, -0.121]

     Rotate by [0, 0.707, 0, 0.707] (Y=90°):
       Rotation matrix for +90° around Y:
         [ 0  0  1]
         [ 0  1  0]
         [-1  0  0]

       Applying [x,y,z] → [z, y, -x]:
         [2.0, 1.5, -0.121] → [-0.121, 1.5, -2.0]

     wall.anchor_world = [-0.121, 1.5, -2.0]

  C. Solve for wall pivot:
     Formula: p_world_new = target_point - anchor_world

     p_world_wall = floor.right_world - wall.anchor_world
     p_world_wall = [4.0, -0.05, -2.0] - [-0.121, 1.5, -2.0]
     p_world_wall = [4.121, -1.55, 0.0]

Step 5 - Verify (optional sanity check):

  Recalculate wall.back world position:
    wall.back_world = p_world_wall + wall.anchor_world
    wall.back_world = [4.121, -1.55, 0.0] + [-0.121, 1.5, -2.0]
    wall.back_world = [4.0, -0.05, -2.0] ✓

  Check against floor.right:
    floor.right_world = [4.0, -0.05, -2.0] ✓ Perfect match!

OUTPUT TO TOOL:
  position = [4.121, -1.55, 0.0]
  rotation = [0, 0.707, 0, 0.707]  (quaternion [x,y,z,w], NOT Euler angles!)
  scale = [1.0, 1.0, 1.0]

CRITICAL NOTES:

1. Floor not in Scene Context yet (just created):
   - We have instance transform: p_wl_floor, R_wl_floor from creation
   - Calculate R_ws_floor = R_wl_floor * R_ls_floor⁻¹
   - Transform SLS → WORLD for position calculation

2. Quaternion rotation:
   - [0, 0.707, 0, 0.707] represents +90° around Y axis
   - Rotation matrix applies [x,y,z] → [z, y, -x]
   - Always verify rotation direction matches desired alignment

3. Position calculation in WORLD:
   - All position math happens in world space
   - SLS is only for reasoning (alignment, normals)
   - Output is world coordinates for tool call

4. Wall consistency reminder:
   - Use wall.back (or wall.front) consistently for ALL walls
   - Never mix different semantic points for different walls
   - Verify all 4 walls use same anchor point before tool call
